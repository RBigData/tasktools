% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mpi_napply.r
\name{mpi_napply}
\alias{mpi_napply}
\title{mpi_napply}
\usage{
mpi_napply(n, FUN, ..., checkpoint_path = NULL, preschedule = TRUE)
}
\arguments{
\item{n}{A global, positive integer.}

\item{FUN}{Function to evaluate.}

\item{...}{Additional arguments passed to \code{FUN}.}

\item{checkpoint_path}{If a path is specified, then each MPI rank will write checkpoints to disk
during execution. If this path is global (the same on all ranks), then that
path should be accessible to all ranks. However, a local path pointing to
node-local storage can also be used. All checkpoint files will be removed on
successful completion of the function. If the value is the default
\code{NULL}, then no checkpointing takes place.}

\item{preschedule}{Should the jobs be distributed among the MPI ranks up front? Otherwise, the
jobs will be evaluated on a "first come first serve" basis among the ranks.}
}
\value{
A list on rank 0.
}
\description{
A distributed "n-apply" function. Syntactically, this is sugar for a
distributed \code{lapply(1:n, FUN)}.
}
\details{
If \code{preschedule=FALSE} then jobs are likely to be evaluated out of order
(that's actually the point). However, the return is reconstructed in the
linear order, so that the first element of the return list is the value
resulting from evaluating \code{FUN} at 1, the second at 2, and so on.
}

